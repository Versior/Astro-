---
import { menuLinks, siteConfig, friends } from "@/site.config";
---
<footer
  class="mt-auto flex w-full flex-col items-center justify-center gap-y-1 pb-4 pt-10 text-center align-top font-semibold text-gray-600 dark:text-gray-400"
>
  <div class="flex flex-col w-full gap-y-1">
    <div class="text-center text-[9px]">
      &copy; {siteConfig.author}
    </div>
    <!-- 运行时间 -->
    <div class="uptime-section text-center text-[9px]">
      本站已运行: <span id="site-uptime">0秒</span>
    </div>
    <!-- 统计容器：今日访客数 + 总访问量 -->
    <div class="text-center text-[9px]">
      <span>今日访客数:<span id="today-uv">--</span>人次</span> | 
      <span>总访问量:<span id="total-pv">--</span>次</span>
    </div>
  </div>

  <nav
    aria-label="More on this site"
    class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500 mt-1"
  >
    {
      friends.map((link) => (
        <a 
          key={link.url} 
          class="px-4 py-2 text-[9px] sm:py-0 sm:hover:text-textColor sm:hover:underline" 
          href={link.url} 
          target="_blank" 
          rel="noopener noreferrer"
        >
          {link.name}
        </a>
      ))
    }
  </nav>

  <!-- 核心脚本：合并+延迟+精简 -->
  <script is:inline>
    // 1. 性能优化：提前缓存DOM元素（减少重复查询）
    const dom = {
      uptime: document.getElementById('site-uptime'),
      todayUV: document.getElementById('today-uv'),
      totalPV: document.getElementById('total-pv')
    };

    // 2. 运行时间（精简逻辑，避免冗余计算）
    if (dom.uptime) {
      const startTime = new Date('2018-07-18T00:00:00Z');
      const updateUptime = () => {
        const seconds = Math.floor((new Date() - startTime) / 1000);
        const days = Math.floor(seconds / 86400);
        const hours = Math.floor((seconds % 86400) / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;
        dom.uptime.textContent = `${days} 天 ${hours.toString().padStart(2, '0')} 时 ${mins.toString().padStart(2, '0')} 分 ${secs.toString().padStart(2, '0')} 秒`;
      };
      updateUptime();
      setInterval(updateUptime, 1000); // 必要的定时器，无法省略
    }

    // 3. 今日访客数（本地存储优化：减少读写次数）
    const initTodayUV = () => {
      if (!dom.todayUV) return;
      const today = new Date().toISOString().split('T')[0];
      const storageKey = `uv_${today}`;
      const globalKey = `total_uv_${today}`;

      // 仅在首次访问时更新存储（减少localStorage写入）
      if (!localStorage.getItem(storageKey)) {
        localStorage.setItem(storageKey, '1');
        const current = localStorage.getItem(globalKey) || '0';
        localStorage.setItem(globalKey, String(+current + 1));
      }

      // 先显示本地数据（快速响应）
      dom.todayUV.textContent = localStorage.getItem(globalKey) || '1';
    };

    // 4. 总访问量（优先本地缓存，后同步远程）
    const initTotalPV = () => {
      if (!dom.totalPV) return;
      // 先显示本地缓存（避免等待远程响应）
      const localPV = localStorage.getItem('total_pv') || '1';
      dom.totalPV.textContent = localPV;

      // 异步加载统计脚本（非关键资源，不阻塞渲染）
      const loadStatsScript = () => {
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/gh/ibruce/busuanzi@2.3/busuanzi.pure.mini.js';
        script.async = true; // 异步加载，不阻塞HTML解析
        script.defer = true; // 延迟执行，等DOM就绪

        // 脚本加载成功：同步远程数据（覆盖本地）
        script.onload = () => {
          if (window.busuanzi?.value?.site_pv) {
            dom.totalPV.textContent = busuanzi.value.site_pv;
            localStorage.setItem('total_pv', busuanzi.value.site_pv); // 缓存远程数据
          }
        };

        // 脚本加载失败：仅更新本地计数（不重复写入）
        script.onerror = () => {
          localStorage.setItem('total_pv', String(+localPV + 1));
        };

        document.body.appendChild(script);
      };

      // 延迟加载统计脚本（等页面核心内容渲染完成）
      requestIdleCallback(loadStatsScript, { timeout: 2000 });
    };

    // 5. 初始化入口（等DOM就绪后执行，避免提前查询）
    document.addEventListener('DOMContentLoaded', () => {
      initTodayUV();
      initTotalPV();
    });
  </script>
</footer>
