---
import { menuLinks, siteConfig, friends } from "@/site.config";
---
<footer
  class="mt-auto flex w-full flex-col items-center justify-center gap-y-1 pb-4 pt-10 text-center align-top font-semibold text-gray-600 dark:text-gray-400"
>
  <div class="flex flex-col w-full gap-y-1">
    <div class="text-center text-[9px]">
      &copy; {siteConfig.author}
    </div>
    <div class="uptime-section text-center text-[9px]">
      本站已运行: <span id="site-uptime">0秒</span>
    </div>
    <div class="text-center text-[9px]">
      <span>
        访客数:<span id="count-uv">加载中...</span>人次
      </span> | 
      <span>
        总访问量:<span id="count-pv">加载中...</span>次
      </span>
    </div>
  </div>

  <nav
    aria-label="More on this site"
    class="flex gap-x-2 sm:gap-x-0 sm:divide-x sm:divide-gray-500 mt-1"
  >
    {
      friends.map((link) => (
        <a 
          key={link.url} 
          class="px-4 py-2 text-[9px] sm:py-0 sm:hover:text-textColor sm:hover:underline" 
          href={link.url} 
          target="_blank" 
          rel="noopener noreferrer"
        >
          {link.name}
        </a>
      ))
    }
  </nav>

  <script is:inline>
    // 1. 运行时间逻辑（保持不变）
    try {
      document.addEventListener('DOMContentLoaded', () => {
        const uptimeElement = document.getElementById('site-uptime');
        const startTime = new Date('2018-07-18T00:00:00Z');
        if (!uptimeElement) return;

        function formatTime(seconds) {
          const days = Math.floor(seconds / (24 * 60 * 60));
          seconds %= 24 * 60 * 60;
          const hours = Math.floor(seconds / (60 * 60));
          seconds %= 60 * 60;
          const minutes = Math.floor(seconds / 60);
          const secondsRemaining = seconds % 60;
          return `${days} 天 ${String(hours).padStart(2, '0')} 时 ${String(minutes).padStart(2, '0')} 分 ${String(secondsRemaining).padStart(2, '0')} 秒`;
        }

        function updateUptime() {
          const now = new Date();
          const seconds = Math.floor((now - startTime) / 1000);
          uptimeElement.textContent = formatTime(seconds);
        }

        updateUptime();
        setInterval(updateUptime, 1000);
      });
    } catch (error) {
      console.error('运行时间脚本报错：', error);
      document.getElementById('site-uptime').textContent = '计算失败';
    }

    // 2. CountAPI 统计（强化版）
    async function initCountAPI() {
      // 替换为你的专属ID（必须改！只能包含字母、数字、-、_）
      const siteId = "versior"; 
      // 备用API地址（多个地址提高成功率）
      const apiUrls = [
        "https://countapi.xyz",      // 主地址（无api前缀，更稳定）
        "https://api.countapi.xyz"   // 备用地址
      ];

      // 工具函数：尝试所有API地址，返回第一个成功的响应
      async function tryFetch(path) {
        for (const baseUrl of apiUrls) {
          try {
            const res = await fetch(`${baseUrl}${path}`);
            if (!res.ok) throw new Error(`API返回错误：${res.status}`);
            return await res.json();
          } catch (error) {
            console.log(`地址 ${baseUrl} 失败：`, error.message);
            continue; // 尝试下一个地址
          }
        }
        throw new Error("所有API地址均失败");
      }

      // 2.1 总访问量（PV）：优先用API，失败则用本地存储
      const pvElement = document.getElementById('count-pv');
      try {
        const pvData = await tryFetch(`/hit/${siteId}/pv`);
        pvElement.textContent = pvData.value || '0';
        localStorage.setItem('local_pv', pvData.value); // 同步到本地
      } catch (error) {
        console.error('PV统计失败：', error);
        // 用本地存储的历史数据（无则显示1）
        const localPv = localStorage.getItem('local_pv') || '1';
        pvElement.textContent = localPv;
        // 本地+1（确保刷新时增长）
        localStorage.setItem('local_pv', String(Number(localPv) + 1));
      }

      // 2.2 访客数（UV）：优先用API，失败则用本地存储
      const uvElement = document.getElementById('count-uv');
      try {
        const uvKey = `local_uv_${siteId}`;
        const today = new Date().toISOString().split('T')[0];
        const storedDate = localStorage.getItem(uvKey);

        // 今天未统计过，则尝试API+1
        if (storedDate !== today) {
          await tryFetch(`/hit/${siteId}/uv`);
          localStorage.setItem(uvKey, today);
        }

        // 获取UV总数
        const uvData = await tryFetch(`/get/${siteId}/uv`);
        uvElement.textContent = uvData.value || '0';
        localStorage.setItem('local_uv', uvData.value); // 同步到本地
      } catch (error) {
        console.error('UV统计失败：', error);
        // 用本地存储的历史数据（无则显示1）
        const localUv = localStorage.getItem('local_uv') || '1';
        uvElement.textContent = localUv;
        // 今天未统计过，则本地+1
        const uvKey = `local_uv_${siteId}`;
        const today = new Date().toISOString().split('T')[0];
        if (localStorage.getItem(uvKey) !== today) {
          localStorage.setItem('local_uv', String(Number(localUv) + 1));
          localStorage.setItem(uvKey, today);
        }
      }
    }

    // 启动统计（DOM加载后）
    document.addEventListener('DOMContentLoaded', initCountAPI);
  </script>
</footer>
